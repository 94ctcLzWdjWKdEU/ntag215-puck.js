{"version":3,"file":"xxxxxxxxxxxxxxxxxxxx.js","mappings":"+QA6CO,MAAMA,EAMXC,YAAYC,IAAqB,+HAC/BC,KAAKD,OAASA,EACdC,KAAKC,QAAU,KACfD,KAAKE,SAAW,KAChBF,KAAKG,YAAcH,KAAKI,MACzB,CAEiB,aAChBJ,KAAKC,cAAgBI,IAAAA,UAAgBL,KAAKD,QAC1C,MAAMO,EAAeN,KAAKC,QAAQM,KAAK,iBAEvC,GAAqB,OAAjBD,EAGF,MAAM,IAAIE,MAAM,0DAFhBR,KAAKE,SAAWO,KAAKC,YAAYJ,EAAaK,MAAM,WAAWT,QAIlE,CAEqB,uBACdF,KAAKG,YAD0E,2BAA7DS,EAA6D,yBAA7DA,EAA6D,gBAGrF,IAAK,MAAMC,KAAQD,EACjB,GAAIZ,KAAKE,SAASW,GAAO,CACvB,MAAMC,EAAQd,KAAKE,SAASW,GACtBE,EAAgC,CACpCF,OACAG,SAAUF,EAAMG,SAChBC,UAAWJ,EAAMK,SACjBC,SAAU,KACVC,UAAW,MAMb,OAHAN,EAAOK,eAAiBpB,KAAKC,QAAQM,KAAKQ,EAAOC,UAAUL,MAAM,eACjEI,EAAOM,gBAAkBrB,KAAKC,QAAQM,KAAKQ,EAAOG,WAAWP,MAAM,eAE5DI,CACR,CAEJ,CAEiB,qBAChB,OAAOf,KAAKsB,SAAS,aAAc,aAAc,wBAClD,CAEgB,oBACf,OAAOtB,KAAKsB,SAAS,cACtB,EC9FH,MAAMC,EAAQC,EAAQ,MAGhBC,EAA8C,kCAa7C,MAAMC,EAUX5B,YAAY6B,EAAmEC,EAAgEC,IAAsE,2IACnN7B,KAAK4B,YAAcA,EACnB5B,KAAK2B,eAAiBA,EACtB3B,KAAK6B,iBAAmBA,EACxB7B,KAAK8B,IAAM,IAAIC,IAAJ,CAAcR,EAAMS,KAC/BhC,KAAK8B,IAAIG,iBAAiBF,IAAAA,UAAqBH,GAC/C5B,KAAK8B,IAAIG,iBAAiBF,IAAAA,eAA0BF,EACrD,CAEwB,oBACvB,OAAO,IAAIhC,SAAwB4B,GAAUS,QAC9C,CAEW,eACV,MAAMC,QAAsBnC,KAAKoC,cAC3BC,QAAkBF,EAAcG,eAChCC,QAAiBJ,EAAcK,oBAE/BxC,KAAK2B,eAAe,CAAEc,QAAS,yBACrC,MAAMC,QAAe1C,KAAK8B,IAAIa,eAAc,EAAO,MAEnD,IAAK,MAAMC,IAAS,CAACP,EAAWE,GAC1BK,UACI5C,KAAK2B,eAAe,CAAEc,QAAU,YAAWG,EAAM/B,SAAS+B,EAAM1B,uBAChElB,KAAK8B,IAAIe,OAAOH,EAAQE,EAAMxB,SAAUwB,EAAMvB,kBAIlDrB,KAAK2B,eAAe,CAAEc,QAAS,mBAAoBK,OAAO,GACjE,EAGInC,eAAeoC,UACdtB,CACP,E,OA5CYC,EAAAA,YACQ,Q,OADRA,EAAAA,iBAEa,a,OAFbA,EAAAA,eAGW,S","sources":["https://dantheman827.github.io/ntag215-puck.js/./src/SecureDfuPackage.ts","https://dantheman827.github.io/ntag215-puck.js/./src/SecureDfuUpdate.ts"],"sourcesContent":["/*\n* Web Bluetooth DFU\n* Copyright (c) 2022 Daniel Radtke - Typescript translation\n* Copyright (c) 2018 Rob Moran\n*\n* The MIT License (MIT)\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\n\nimport JSZip from \"jszip\"\n\nexport interface DfuPackageApplication {\n  bin_file: string,\n  dat_file: string\n}\n\nexport interface DfuPackageManifest {\n  [key: string]: DfuPackageApplication | undefined\n}\n\nexport interface DfuPackageImageResult {\n  type: string\n  initFile: string\n  imageFile: string\n  initData: ArrayBuffer\n  imageData: ArrayBuffer\n}\n\nexport class SecureDfuPackage {\n  buffer: ArrayBuffer\n  zipFile: JSZip\n  manifest: DfuPackageManifest\n  private loadPromise: Promise<void>\n\n  constructor(buffer: ArrayBuffer) {\n    this.buffer = buffer\n    this.zipFile = null\n    this.manifest = null\n    this.loadPromise = this.load()\n  }\n\n  private async load() {\n    this.zipFile = await JSZip.loadAsync(this.buffer)\n    const manifestFile = this.zipFile.file(\"manifest.json\")\n\n    if (manifestFile !== null) {\n      this.manifest = JSON.parse(await manifestFile.async(\"string\")).manifest\n    } else {\n      throw new Error(\"Unable to find manifest, is this a proper DFU package?\")\n    }\n  }\n\n  private async getImage(...types: string[]): Promise<DfuPackageImageResult | undefined> {\n    await this.loadPromise\n\n    for (const type of types) {\n      if (this.manifest[type]) {\n        const entry = this.manifest[type]\n        const result: DfuPackageImageResult = {\n          type,\n          initFile: entry.dat_file,\n          imageFile: entry.bin_file,\n          initData: null,\n          imageData: null\n        }\n\n        result.initData = await this.zipFile.file(result.initFile).async(\"arraybuffer\")\n        result.imageData = await this.zipFile.file(result.imageFile).async(\"arraybuffer\")\n\n        return result\n      }\n    }\n  }\n\n  async getBaseImage(): Promise<DfuPackageImageResult | undefined> {\n    return this.getImage(\"softdevice\", \"bootloader\", \"softdevice_bootloader\")\n  }\n\n  async getAppImage(): Promise<DfuPackageImageResult | undefined> {\n    return this.getImage(\"application\")\n  }\n}\n","import SecureDfu from \"web-bluetooth-dfu\"\nimport { SecureDfuPackage } from \"./SecureDfuPackage\"\n\nconst CRC32 = require(\"crc-32\")\n\n// @ts-ignore:next-line\nconst firmware: Promise<{ default: ArrayBuffer }> = import(\"arraybuffer-loader!../espruino_2v15.1_puckjs.zip\")\n\nexport interface SecureDfuUpdateProgress {\n  object: string\n  totalBytes: number\n  currentBytes: number\n}\n\nexport interface SecureDfuUpdateMessage {\n  message: string\n  final?: boolean\n}\n\nexport class SecureDfuUpdate {\n  static EVENT_LOG = \"log\"\n  static EVENT_PROGRESS = \"progress\"\n  static EVENT_STATUS = \"status\"\n\n  dfu: SecureDfu\n  logCallback: (message: SecureDfuUpdateMessage) => Promise<any>\n  progressCallback: (message: SecureDfuUpdateProgress) => Promise<any>\n  statusCallback: (message: SecureDfuUpdateMessage) => Promise<any>\n\n  constructor(statusCallback: (message: SecureDfuUpdateMessage) => Promise<any>, logCallback: (message: SecureDfuUpdateMessage) => Promise<any>, progressCallback: (message: SecureDfuUpdateProgress) => Promise<any>) {\n    this.logCallback = logCallback\n    this.statusCallback = statusCallback\n    this.progressCallback = progressCallback\n    this.dfu = new SecureDfu(CRC32.buf)\n    this.dfu.addEventListener(SecureDfu.EVENT_LOG, logCallback)\n    this.dfu.addEventListener(SecureDfu.EVENT_PROGRESS, progressCallback)\n  }\n\n  private async loadPackage(): Promise<SecureDfuPackage> {\n    return new SecureDfuPackage((await firmware).default)\n  }\n\n  async update() {\n    const updatePackage = await this.loadPackage()\n    const baseImage = await updatePackage.getBaseImage()\n    const appImage = await updatePackage.getAppImage()\n\n    await this.statusCallback({ message: \"Connecting to device\" })\n    const device = await this.dfu.requestDevice(false, null)\n\n    for (const image of [baseImage, appImage]) {\n      if (image) {\n        await this.statusCallback({ message: `Updating ${image.type}: ${image.imageFile}...` })\n        await this.dfu.update(device, image.initData, image.imageData);\n      }\n    }\n\n    await this.statusCallback({ message: \"Update complete!\", final: true })\n  }\n}\n\nexport async function waitForFirmware() {\n  await firmware\n}\n"],"names":["SecureDfuPackage","constructor","buffer","this","zipFile","manifest","loadPromise","load","JSZip","manifestFile","file","Error","JSON","parse","async","types","type","entry","result","initFile","dat_file","imageFile","bin_file","initData","imageData","getImage","CRC32","require","firmware","SecureDfuUpdate","statusCallback","logCallback","progressCallback","dfu","SecureDfu","buf","addEventListener","default","updatePackage","loadPackage","baseImage","getBaseImage","appImage","getAppImage","message","device","requestDevice","image","update","final","waitForFirmware"],"sourceRoot":""}